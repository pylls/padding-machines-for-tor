#!/usr/bin/env python3
from enum import Enum
import copy
import random
import hashlib

# the possible discrete distributions
class DistType(Enum):
    NONE = "CIRCPAD_DIST_NONE"
    UNIFORM = "CIRCPAD_DIST_UNIFORM"
    LOGISTIC = "CIRCPAD_DIST_LOGISTIC"
    LOG_LOGISTIC = "CIRCPAD_DIST_LOG_LOGISTIC"
    GEOMETRIC = "CIRCPAD_DIST_GEOMETRIC"
    WEIBULL = "CIRCPAD_DIST_WEIBULL"
    PARETO = "CIRCPAD_DIST_PARETO"

class Distribution:
    def __init__(self, dist_type=DistType.NONE, param1=0, param2=0):
        self.dist_type = dist_type
        self.param1 = param1
        self.param2 = param2
    
    def __str__(self):
        return f"{self.dist_type} {self.param1:.2f} {self.param2:.2f}"

    def randomize(self, a, b):
        self.dist_type = random.choice(list(DistType))
        self.param1 = random.uniform(a,b)
        self.param2 = random.uniform(a,b)
        return self

# the events specified by struct circpad_event_t
class Event(Enum):
    # a non-padding cell was received
    NONPADDING_RECV = "CIRCPAD_EVENT_NONPADDING_RECV"
    # a non-padding cell was sent
    NONPADDING_SENT = "CIRCPAD_EVENT_NONPADDING_SENT"
    # a padding cell (RELAY_COMMAND_DROP) was sent
    PADDING_SENT = "CIRCPAD_EVENT_PADDING_SENT"
    # a padding cell was received
    PADDING_RECV = "CIRCPAD_EVENT_PADDING_RECV"
    # we tried to schedule padding but we ended up picking the infinity bin
    # which means that padding was delayed infinitely
    INFINITY = "CIRCPAD_EVENT_INFINITY"
    # all histogram bins are empty (we are out of tokens) 
    BINS_EMPTY = "CIRCPAD_EVENT_BINS_EMPTY"
    # out of allowed cells to send in state
    LENGTH_COUNT = "CIRCPAD_EVENT_LENGTH_COUNT"

class MachineState:
    # TODO histogram with iat_histogram and token_removal
    def __init__(
        self,
        # IAT-dist
        iat_dist=None,
        # dist_added_shift_usec
        iat_dist_add=0,
        # dist_max_sample_usec
        iat_dist_max=None,
        # length-dist
        length_dist=None,
        # start_length
        length_dist_add=0,
        # max_length
        length_dist_max=None,
        # should we decrement length when we see a nonpadding packet?
        length_includes_nonpadding=False,
        # the transitions from this state, we ignore by default
        transitions = []
        ):
        self.iat_dist = iat_dist
        self.iat_dist_add = iat_dist_add
        self.iat_dist_max = iat_dist_max
        self.length_dist = length_dist
        self.length_dist_add = length_dist_add
        self.length_dist_max = length_dist_max
        self.length_includes_nonpadding = length_includes_nonpadding
        self.transitions = transitions
    
    def __str__(self):
        r = f"\tiat-dist {self.iat_dist}"
        if self.iat_dist_add > 0 or self.iat_dist_max != None:
            r += f" clamped to  [{self.iat_dist_add}, {self.iat_dist_max}],\n"
        
        r += f"\tlength-dist {self.length_dist}"
        if self.length_dist_add > 0 or self.length_dist_max != None:
            r += f" clamped to [{self.length_dist_add}, {self.length_dist_max}],\n"
        
        if self.length_includes_nonpadding:
            r += f"\tlength_includes_nonpadding,\n"

        if len(self.transitions) == 0:
            r += f"\tno transitions"
        else:
            r += f"\ttransitions\n\t["
            for t in self.transitions:
                r += f"\n\t\t{t[0]} -> {t[1]},"
            r += f"\n\t]"

        return r
    
    def to_c(self, prefix):
        '''
        Returns c code with the prefix added for each line. 

        The prefix should be generated by the caller in a format to fit the
        following format _before_ the first . (excluding the dot):

        machine->states[index].length_dist.type = CIRCPAD_DIST_UNIFORM;

        One possible prefix would be "machine->states[1]" for the "machine"
        variable name and the state with index 1.
        '''

        c = ""
        prefix = f"\n{prefix}"

        if not self.length_dist is None:
            c += f"{prefix}.length_dist.type = {self.length_dist.dist_type.value};"
            c += f"{prefix}.length_dist.param1 = {self.length_dist.param1};"
            c += f"{prefix}.length_dist.param2 = {self.length_dist.param2};"
            
            if self.length_dist_add > 0:
                c += f"{prefix}.start_length = {self.length_dist_add};"

            if not self.length_dist_max is None:
                c += f"{prefix}.max_length = {self.length_dist_max};"

        if not self.iat_dist is None:
            c += f"{prefix}.iat_dist.type = {self.iat_dist.dist_type.value};"
            c += f"{prefix}.iat_dist.param1 = {self.iat_dist.param1};"
            c += f"{prefix}.iat_dist.param2 = {self.iat_dist.param2};"
            
            if self.iat_dist_add > 0:
                c += f"{prefix}.dist_added_shift_usec = {self.iat_dist_add};"

            if not self.iat_dist_max is None:
                c += f"{prefix}.dist_max_sample_usec = {self.iat_dist_max};"
            else:
                # BUG: circuitpadding.c, line 560, should check if set like for length
                c += f"{prefix}.dist_max_sample_usec = CIRCPAD_DELAY_INFINITE;"

        if self.length_includes_nonpadding:
            c += f"{prefix}.length_includes_nonpadding = 1;"

        for t in self.transitions:
            c += f"{prefix}.next_state[{t[0].value}] = {t[1]};"

        return c

    def randomize(self, exp):
        self.randomize_iat_dist(exp)
        self.randomize_length_dist(exp)
        self.randomize_transitions(exp)
        return self
    
    def randomize_iat_dist(
        self,
        exp,
        probability=1.0,
        ):
        if random.random() < probability:
            self.iat_dist = Distribution().randomize(
                exp["iat_d_low"], 
                exp["iat_d_high"]
            )
        if random.random() < probability:
            self.iat_dist_add = random.randint(
                exp["iat_a_low"], 
                exp["iat_a_high"]
            )
        if random.random() < probability:
            self.iat_dist_max = random.randint(
                exp["iat_m_low"], 
                exp["iat_m_high"]
            )

    def randomize_length_dist(
        self,
        exp,
        probability=1.0,
        ):
        if random.random() < probability:
            self.length_dist = Distribution().randomize(
                exp["length_d_low"],
                exp["length_d_high"]
            )
        if random.random() < probability:
            self.length_dist_add = random.randint(
                exp["length_a_low"],
                exp["length_a_high"]
            )
        if random.random() < probability:
            self.length_dist_max = random.randint(
                exp["length_m_low"],
                exp["length_m_high"]
            )

    def randomize_transitions(
        self,
        exp,
        probability=1.0,
        ):
        # by chance, a state that end up never having any transitions from or to
        # it may appear useless, but like "introns", they are useful "material"
        # later for mutation it seems
        self.transitions = []
        for e in Event:
            # TODO: with histograms we can consider these, for now, ignore
            if e == Event.INFINITY or e == Event.BINS_EMPTY:
                continue
            if random.random() < probability:
                self.transitions.append([e,random.randint(0,exp["num_states"]-1)])


class Machine:
    # TODO: conditions
    def __init__(
        self,
        # just a user-friendly machine name for logs 
        name = "",
        # which machine index slot should this machine go into
        machine_index = 0,
        # send a padding negotiate to shut down machine at end state?
        should_negotiate_end = False,
        # origin side or relay side
        is_origin_side = False,
        # which hop in the circuit should we send padding to/from?
        # 1-indexed (ie: hop #1 is guard, #2 middle, #3 exit).
        target_hopnum = 0,
        # if this flag is enabled, don't close circuits that use this machine
        manage_circ_lifetime = False,
        # how many padding cells can be sent before we apply overhead limits?
        allowed_padding_count = 0,
        # padding percent cap: Stop padding if we exceed this percent overhead.
        max_padding_percent = 0,
        # list of states
        states = [],
        ):
        self.name = name
        self.machine_index = machine_index
        self.should_negotiate_end = should_negotiate_end
        self.is_origin_side = is_origin_side
        self.target_hopnum = target_hopnum
        self.manage_circ_lifetime = manage_circ_lifetime
        self.allowed_padding_count = allowed_padding_count
        self.max_padding_percent = max_padding_percent
        self.states = states

    def __str__(self):
        r = f"{self.name}, index {self.machine_index}"

        if self.should_negotiate_end:
            r += f", should_negotiate_end"

        if self.is_origin_side:
            r += f", origin side"
        else:
            r += f", relay side"
        
        r += f", sending padding to/from "
        if self.target_hopnum == 0:
            r += f"guard"
        elif self.target_hopnum == 1:
            r += f"middle"
        else:
            r += f"exit"
        
        if self.manage_circ_lifetime:
            r += f", manage_circ_lifetime"
        if self.allowed_padding_count > 0:
            r += f", allowed_padding_count {self.allowed_padding_count}"
        if self.max_padding_percent > 0:
            r += f", max_padding_percent {self.max_padding_percent}"
        
        r += f", states:\n["
        for s in self.states:
            r += f"\n{s}, "
        r += f"\n]"

        return r

    def to_c(self, varname):
       # transforms the machine to c code with the specified variable name

        prefix = f"\n{varname}"
        c = f"{prefix}->name = \"{self.name}\";"
        c += f"{prefix}->machine_index = {self.machine_index};"
        c += f"{prefix}->target_hopnum = {self.target_hopnum};"

        if self.should_negotiate_end:
            c += f"{prefix}->should_negotiate_end = 1;"
        if self.is_origin_side:
            c += f"{prefix}->is_origin_side = 1;"
        else:
            c += f"{prefix}->is_origin_side = 0;"
        if self.manage_circ_lifetime:
            c += f"{prefix}->manage_circ_lifetime = 1;"

        c += f"{prefix}->allowed_padding_count = {self.allowed_padding_count};"
        c += f"{prefix}->max_padding_percent = {self.max_padding_percent};"

        c += f"\ncircpad_machine_states_init({varname}, {len(self.states)});"
        for k, s in enumerate(self.states):
            c += s.to_c(f"{varname}->states[{k}]")

        return c

    def clone(self):
        return copy.deepcopy(self)

    def randomize(self, exp):
        # create a randomized clone of this machine with num_states random states
        r = self.clone()
        r.states = []
        for _ in range(exp["num_states"]):
            r.states.append(MachineState().randomize(exp))

        return r
    
    def id(self):
        return hashlib.sha256(self.to_c("").encode("ascii")).hexdigest()[:16]
